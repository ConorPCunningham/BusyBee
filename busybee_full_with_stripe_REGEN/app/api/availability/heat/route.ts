import { NextRequest, NextResponse } from 'next/server'; import { getClient } from '@/lib/db'; import { withinRadius, coarseCell } from '@/lib/geo'; export async function GET(req:NextRequest){ const prisma=await getClient(); const lat=Number(req.nextUrl.searchParams.get('lat')); const lng=Number(req.nextUrl.searchParams.get('lng')); const radius=Math.max(1,Math.min(50,Number(req.nextUrl.searchParams.get('radius')||10))); if(!Number.isFinite(lat)||!Number.isFinite(lng)) return NextResponse.json({error:'invalid_coords'},{status:400}); const rows=await (prisma as any).helperPresence.findMany({ where:{ status:{ in:['ONLINE','BUSY'] } }, select:{ lat:true,lng:true,status:true,updatedAt:true } }); const now=Date.now(); const fresh=rows.filter((r:any)=> r.lat!=null&&r.lng!=null&&(now-new Date(r.updatedAt).getTime())<5*60*1000); const inRad=fresh.filter((r:any)=> withinRadius(lat,lng,r.lat!,r.lng!,radius)); const buckets:Record<string,{lat:number;lng:number;available:number;busy:number}>={}; for(const r of inRad){ const key=coarseCell(r.lat!,r.lng!); if(!buckets[key]){ const [clat,clng]=key.split(':').map(Number); buckets[key]={lat:clat,lng:clng,available:0,busy:0}; } if(r.status==='ONLINE') buckets[key].available++; else buckets[key].busy++; } const cells=Object.entries(buckets).map(([id,v])=>({id,...v,level: v.available>=4?'high':v.available>=1?'med':'low'})); return NextResponse.json({ok:true,cells,radiusKm:radius}); }
