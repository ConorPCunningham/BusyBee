import { NextRequest, NextResponse } from 'next/server'; import { getClient } from '@/lib/db'; import { getStripe } from '@/lib/stripe'; export async function POST(req:NextRequest){ const stripe=getStripe(); const sig=req.headers.get('stripe-signature')||''; const whsec=process.env.STRIPE_WEBHOOK_SECRET; if(!whsec) return NextResponse.json({error:'missing_webhook_secret'},{status:500}); const raw=await req.text(); let event; try{ event=stripe.webhooks.constructEvent(raw, sig, whsec); }catch(err:any){ return NextResponse.json({error:`invalid signature: ${err.message}`},{status:400}); } const prisma=await getClient(); switch(event.type){ case 'checkout.session.completed': { const session:any=event.data.object; const jobId=session.metadata?.jobId; if(jobId){ await (prisma as any).escrow.update({ where:{ jobId }, data:{ stripeCheckoutSessionId: session.id, stripePaymentIntentId: session.payment_intent||null, status:'HELD' } }).catch(()=>{}); await (prisma as any).job.update({ where:{ id: jobId }, data:{ status:'CONFIRMED' } }).catch(()=>{}); } break; } case 'payment_intent.succeeded': { const pi:any=event.data.object; const jobId=pi.metadata?.jobId; if(jobId){ await (prisma as any).escrow.update({ where:{ jobId }, data:{ stripePaymentIntentId: pi.id, status:'HELD' } }).catch(()=>{}); } break; } case 'charge.dispute.created': { const ch:any=event.data.object; const jobId=ch.metadata?.jobId; if(jobId){ await (prisma as any).escrow.update({ where:{ jobId }, data:{ status:'DISPUTED' } }).catch(()=>{}); } break; } } return NextResponse.json({ received: true }); }
